<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Overfitting in NNs | Matt Log</title>
<meta name="keywords" content="overfitting, cross-validation, weight decay, early stopping, dropout">
<meta name="description" content="In this post we will talk about the problem of overfitting, explaining what it is, what are its causes and how we can deal with it. More precisely, the following techniques will be explained: early stopping, weight decay and dropout.
Disclaimer: These notes are for the most part a collection of concepts taken from the slides of the &lsquo;Artificial Neural Networks and Deep Learning&rsquo; course at Polytechnic of Milan, the book &lsquo;Deep Learning&rsquo; (Goodfellow-et-al-2016) and from some other online resources.">
<meta name="author" content="">
<link rel="canonical" href="https://mett29.github.io/posts/overfitting/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.0f21954db480b5bf5a45ab9ac4b9a7141baaef4db07466e008890636dc132e5d.css" integrity="sha256-DyGVTbSAtb9aRauaxLmnFBuq702wdGbgCIkGNtwTLl0=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://mett29.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://mett29.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://mett29.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://mett29.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://mett29.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[', '\\]']],
        processEscapes: true,
        processEnvironments: true
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
      }
    };
  
    window.addEventListener('load', (event) => {
        document.querySelectorAll("mjx-container").forEach(function(x){
          x.parentElement.classList += 'has-jax'})
      });
  
  </script>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script type="text/javascript" id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><meta property="og:title" content="Overfitting in NNs" />
<meta property="og:description" content="In this post we will talk about the problem of overfitting, explaining what it is, what are its causes and how we can deal with it. More precisely, the following techniques will be explained: early stopping, weight decay and dropout.
Disclaimer: These notes are for the most part a collection of concepts taken from the slides of the &lsquo;Artificial Neural Networks and Deep Learning&rsquo; course at Polytechnic of Milan, the book &lsquo;Deep Learning&rsquo; (Goodfellow-et-al-2016) and from some other online resources." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mett29.github.io/posts/overfitting/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-10-30T22:55:08+02:00" />
<meta property="article:modified_time" content="2019-10-30T22:55:08+02:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Overfitting in NNs"/>
<meta name="twitter:description" content="In this post we will talk about the problem of overfitting, explaining what it is, what are its causes and how we can deal with it. More precisely, the following techniques will be explained: early stopping, weight decay and dropout.
Disclaimer: These notes are for the most part a collection of concepts taken from the slides of the &lsquo;Artificial Neural Networks and Deep Learning&rsquo; course at Polytechnic of Milan, the book &lsquo;Deep Learning&rsquo; (Goodfellow-et-al-2016) and from some other online resources."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Overfitting in NNs",
      "item": "https://mett29.github.io/posts/overfitting/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Overfitting in NNs",
  "name": "Overfitting in NNs",
  "description": "In this post we will talk about the problem of overfitting, explaining what it is, what are its causes and how we can deal with it. More precisely, the following techniques will be explained: early stopping, weight decay and dropout.\nDisclaimer: These notes are for the most part a collection of concepts taken from the slides of the \u0026lsquo;Artificial Neural Networks and Deep Learning\u0026rsquo; course at Polytechnic of Milan, the book \u0026lsquo;Deep Learning\u0026rsquo; (Goodfellow-et-al-2016) and from some other online resources.",
  "keywords": [
    "overfitting", "cross-validation", "weight decay", "early stopping", "dropout"
  ],
  "articleBody": "In this post we will talk about the problem of overfitting, explaining what it is, what are its causes and how we can deal with it. More precisely, the following techniques will be explained: early stopping, weight decay and dropout.\nDisclaimer: These notes are for the most part a collection of concepts taken from the slides of the ‘Artificial Neural Networks and Deep Learning’ course at Polytechnic of Milan, the book ‘Deep Learning’ (Goodfellow-et-al-2016) and from some other online resources. I am simply putting together all the information to study for the exam and I thought it would be a good idea to upload them here since they can be useful for someone who is interested in this topic.\nOverfitting Neural Networks are Universal Approximators Universal Approximation Theorem:\n“A single hidden layer feedforward neural network with S shaped activation functions can approximate any measurable function to any desired degree of accuracy on a compact set.” (Kurt Hornik, 1991)\nIf this is true, why do we always hear about neural networks with tens or even hundreds of hidden layers, with many different activation functions? Well, the theorem states that is possible, but…\n it doesn’t mean that we can find the necessary weights; an exponential number of hidden units may be required; it might be useless in practice if it does not generalize.  The last problem is called overfitting.\nWhat is Overfitting? In statistics, overfitting is “the production of an analysis that corresponds too closely or exactly to a particular set of data, and may therefore fail to fit additional data or predict future observations reliably” (Oxford Dictionaries).\nThe possibility of overfitting exists because the criterion used for selecting the model is not the same as the criterion used to judge the suitability of a model. For example, a model might be selected by maximizing its performance on some set of training data, and yet its suitability might be determined by its ability to perform well on unseen data; then overfitting occurs when a model begins to “memorize” training data rather than “learning” to generalize from a trend.\nAs an extreme example, if the number of parameters is the same as or greater than the number of observations, then a model can perfectly predict the training data simply by memorizing the data in its entirety. Such a model, though, will typically fail severely when making predictions.\nIn the above image, the green line represents an overfitted model. Indeed, even if it is the one that best follows the training data, it is too dependent on that data, thus it will probably have an high error rate on unseen samples.\nA more detailed view of this problem is described in the post Bias-Variance Tradeoff.\nHow can we measure generalization? The training set error is not a valid measure of performance since it’s an optimistically biased estimate of the prediction error. The classifier, indeed, has been learned exactly on that data. Therefore, we need to test on an independent new test set.\nHow can we affect performance on the test set when we get to observe only the training set? If the training and the test set are collected arbitrarily, there is indeed little we can do. If we are allowed to make some assumptions about how the training and test set are collected, then we can make some progress. These assumptions are collectively known as the i.i.d. assumptions, and they imply that the examples in each dataset are independent from each other, and that the train set and the test set are identically distributed, i.e. drawn from the same probability distribution. This probabilistic framework and the i.i.d. assumptions allow us to mathematically study the relationship between training error and test error. [Deep Learning - pag. 111]\nNote however that when we have to train a machine learning algorithm, the latter has many settings called hyperparameters (e.g. $\\lambda$ in weight decay). In order to select the best value for each hyperparameter, we need a set of samples on which tune our model. That’s why, for the same reason that took us to split the dataset in training set and test set, it is good practice to split the dataset into one more set, called validation set.\nFinally all the preparation is done. Summarizing:\n We train the model on the training set We evaluate the model on the validation set We tweak the model according to the results on validation set We select the model that performs best on validation set We test the model on the test set  Important: never train on test data!\nTest sets and validation sets “wear out” with repeated use. That is, the more you use the same data to make decisions about hyperparameter settings or other model improvements, the less confidence you’ll have that these results actually generalize to new, unseen data. [Google ML crash course]\nCross-validation When you have enough data, the method with the validation set described before is a good idea. However, when the dataset is too small you would like to not “waste” so many data that instead could be used for training. Cross-validation techniques solve exactly this problem:\nLeave-Out-Out (LOO) cross-validation A set of $n$ data points is repeatedly split into a training set containing all but one observation, and a validation set that contains only that observation. The test error is then estimated by averaging the $n$ resulting MSE’s.\n$$ L_{LOO} = \\frac{1}{N} \\sum_{n=1}^{N} (t_n - y_{D \\setminus {n}}(x_n))^2 $$\nLOOCV generally gives the best result, but the price to pay is an high computational cost. If the dataset is small, it is the best approach (unless you are Google and you can use it even with a big dataset since the computational power is not a problem).\nK-fold cross-validation A set of $n$ observations is randomly split into $k$ non-overlapping groups. Each of these groups is used as a validation set, and the remainder as a training set. The test error is estimated by averaging the $k$ resulting MSE’s.\n$$ L_{D_i} = \\frac{k}{N} \\sum_{(x_n,t_n) \\in D} (t_n - y_{D \\setminus {D_i}}(x_n))^2 $$\n$$ L_{kfold} = \\frac{1}{k} \\sum_{i=1}^{k} L_{D_i} $$\nK-fold cross-validation is much faster than LOO, but it is more (pessimistically) biased.\nEarly Stopping: Limiting Overfitting by Cross-validation How can we know that our network is overfitting? Overfitting networks show a monotone training error trend (on average with SGD) as the number of gradient descent iterations $k$, but they lose generalization at some point…\nImage taken from https://towardsdatascience.com/cross-validation-70289113a072\nEvery time the error on the validation set improves, we store a copy of the model parameters. When the training algorithm terminates, we return these parameters, rather than the latest parameters. The algorithm terminates when no parameters have improved over the best recorded validation error for some pre-specified number of iterations. It is probably the most commonly used form of regularization in deep learning. Its popularity is due both to its effectiveness and its simplicity.\nThe only significant cost to choosing this hyperparameter automatically via early stopping is running the validation set evaluation periodically during training. Ideally, this is done in parallel to the training process on a separate machine, separate CPU, or separate GPU from the main training process.\nMoreover, since early stopping requires a validation set, some training data are not fed to the model. To overcome this problem, we can perform an extra training procedure with all the data after the one with early stopping has finished. This extra training procedure can be done in two different ways:\n Initialize the model again and retrain with all the data for a number of steps equal to the one determined by the early stopping algorithm. Keep the parameters obtained from the early stopping algorithm and continue training with all the data. Note that this strategy has the advantage of not needing to retrain the model from scratch, but it is not guaranteed to terminate.  If you want to better understand How early stopping acts as a regularizer see the Deep Learning book at page 249. In few words, the idea is that by limiting the number of steps performed by the gradient descent in the loss function that we want to minimize, we are limiting the volume of parameter space reachable from an initial parameter. So we can say that somehow early stopping is similar to weight decay, but with the advantage that it can figure out for itself what is the right amount of regularization to apply, while weight decay needs to tune its $\\lambda$ parameter (e.g. by cross-validation).\nWeight Decay I’ve already discussed this technique in another post – Linear Regression\nHowever, I will do it again here, adding some details.\nRegularization is any modification we make to a learning algorithm that is intended to reduce its generalization error but not its training error. In case of weight decay, regularization consists of adding a penalty term to the loss function to discourage the coefficients from reaching large values.\nSo far we have maximized the data likelihood $w_{MLE} = argmax_w P(D|w)$. We can reduce the model “freedom” by introducing a prior distribution which influences the choice of the point estimate. This approach is called **Maximum A Posteriori (MAP)**:\n$$ \\theta_{MAP} = argmax_{\\theta}\\; p(\\theta|x) = argmax_{\\theta}\\; log\\; p(x|\\theta) + log\\; p(\\theta) $$\nwhere on the right hand side the first term is the likelihood and the second one the prior distribution.\nConsider now a linear regression model with a Gaussian prior on the weights $P(w) \\sim N(0,\\sigma_w^2)$.\n$$ \\displaylines{\\hat{w} = argmax_w P(w|D) = argmax_w P(D|w) P(w) \\\\ = argmax_w \\prod_{n=1}^{N} \\frac{1}{\\sqrt{2\\pi}\\sigma} e^{-\\frac{(t_n-g(x_n|w))^2}{2\\sigma^2}} \\prod_{q=1}^{Q} \\frac{1}{\\sqrt{2\\pi}\\sigma_w} e^{-\\frac{(w_q)^2}{2\\sigma_w^2}} \\\\ = argmin_w \\sum_{n=1}^{N} \\frac{(t_n-g(x_n|w))^2}{2\\sigma^2} + \\sum_{q=1}^{Q} \\frac{(w_q)^2}{2\\sigma_w^2} \\\\ = argmin_w \\sum_{n=1}^{N} (t_n-g(x_n|w))^2 + \\gamma \\sum_{q=1}^{Q} (w_q)^2} $$\nWe thus have obtained a new loss function, where the second term represents the regularization. Minimizing this loss function results in a choice of weights that make a tradeoff between fitting the training data and being small. This gives us solutions that have a smaller slope, or put weight on fewer of the features.\nDropout Dropout is one of the most simple but efficient techniques to regularize neural networks. The idea is pretty simple, but let’s make a premise: in machine learning there is one technique called bagging in which different models are trained through the use of bootstrapping. The main goal of this technique is to reduce the variance of the overall model, with the advantage that the training process is relatively easy to parallelize.\nOk, so one could think of using this approach also in neural networks. Here is the problem: with very large neural networks this becomes easily impractical. Dropout provides an inexpensive approximation to training and evaluating a bagged ensemble of exponentially many neural networks. By turning off randomly some neurons, we force to learn an independent feature preventing hidden units to rely on other units (co-adaptation). Specifically, to train with dropout, we use a minibatch-based learning algorithm that makes small steps, such as stochastic gradient descent. Each time we load an example into a minibatch, we randomly sample a different binary mask to apply to all of the input and hidden units in the network. The mask for each unit is sampled independently from all of the others. The probability of sampling a mask value of one (causing a unit to be included) is a hyperparameter fixed before training begins.\nImage taken from Defensive Dropout for Hardening Deep Neural Networks under Adversarial Attacks\nNote that there are two important differences between dropout and bagging:\n  In the case of bagging, the models are all independent. In the case of dropout the models share parameters, with each model inheriting a different subset of parameters from the parent neural network. This parameter sharing makes it possible to represent an exponential number of models with a tractable amount of memory.\n  In the case of bagging, each model is trained to convergence on its respective training set. In the case of dropout, typically most models are not explicitly trained at all—usually, the model is large enough that it would be infeasible to sample all possible subnetworks within the lifetime of the universe. Instead, a tiny fraction of the possible sub-networks are each trained for a single step, and the parameter sharing causes the remaining sub-networks to arrive at good settings of the parameters.\n  An interesting consequence of the fact that dropout trains not just a bagged ensemble of models, but an ensemble of models that share hidden units is that each hidden unit must be able to perform well regardless of which other hidden units are in the model. Hidden units must be prepared to be swapped and interchanged between models. Hinton et al. (2012c) were inspired by an idea from biology: sexual reproduction, which involves swapping genes between two different organisms, creates evolutionary pressure for genes to become not just good, but to become readily swapped between different organisms. Such genes and such features are very robust to changes in their environment because they are not able to incorrectly adapt to unusual features of any one organism or model. Dropout thus regularizes each hidden unit to be not merely a good feature but a feature that is good in many contexts.\n",
  "wordCount" : "2192",
  "inLanguage": "en",
  "datePublished": "2019-10-30T22:55:08+02:00",
  "dateModified": "2019-10-30T22:55:08+02:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://mett29.github.io/posts/overfitting/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Matt Log",
    "logo": {
      "@type": "ImageObject",
      "url": "https://mett29.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://mett29.github.io/" accesskey="h" title="Matt Log (Alt + H)">Matt Log</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://mett29.github.io/archive/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://mett29.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Overfitting in NNs
    </h1>
    <div class="post-meta"><span title='2019-10-30 22:55:08 +0200 +0200'>October 30, 2019</span>

</div>
  </header> 
  <div class="post-content"><p>In this post we will talk about the problem of <strong>overfitting</strong>, explaining what it is, what are its causes and how we can deal with it. More precisely, the following techniques will be explained: <strong>early stopping</strong>, <strong>weight decay</strong> and <strong>dropout</strong>.</p>
<p><strong>Disclaimer:</strong> <em>These notes are for the most part a collection of concepts taken from the slides of the &lsquo;Artificial Neural Networks and Deep Learning&rsquo; course at Polytechnic of Milan, the book &lsquo;Deep Learning&rsquo; (Goodfellow-et-al-2016) and from some other online resources. I am simply putting together all the information to study for the exam and I thought it would be a good idea to upload them here since they can be useful for someone who is interested in this topic.</em></p>
<h1 id="overfitting">Overfitting<a hidden class="anchor" aria-hidden="true" href="#overfitting">#</a></h1>
<h2 id="neural-networks-are-universal-approximators">Neural Networks are Universal Approximators<a hidden class="anchor" aria-hidden="true" href="#neural-networks-are-universal-approximators">#</a></h2>
<p><strong>Universal Approximation Theorem:</strong></p>
<p><em>&ldquo;A single hidden layer feedforward neural network with S shaped activation functions can approximate any measurable function to any desired degree of accuracy on a compact set.&rdquo; (Kurt Hornik, 1991)</em></p>
<p>If this is true, why do we always hear about neural networks with tens or even hundreds of hidden layers, with many different activation functions? Well, the theorem states that is possible, but&hellip;</p>
<ul>
<li>it doesn&rsquo;t mean that we can find the necessary weights;</li>
<li>an exponential number of hidden units may be required;</li>
<li>it might be useless in practice if it does not generalize.</li>
</ul>
<p>The last problem is called <strong>overfitting</strong>.</p>
<h2 id="what-is-overfitting">What is Overfitting?<a hidden class="anchor" aria-hidden="true" href="#what-is-overfitting">#</a></h2>
<p>In statistics, overfitting is <em>&ldquo;the production of an analysis that corresponds too closely or exactly to a particular set of data, and may therefore fail to fit additional data or predict future observations reliably&rdquo;</em> (Oxford Dictionaries).</p>
<p>The possibility of overfitting exists because the criterion used for selecting the model is not the same as the criterion used to judge the suitability of a model. For example, a model might be selected by maximizing its performance on some set of training data, and yet its suitability might be determined by its ability to perform well on unseen data; then overfitting occurs when a model begins to &ldquo;memorize&rdquo; training data rather than &ldquo;learning&rdquo; to generalize from a trend.</p>
<p>As an extreme example, if the number of parameters is the same as or greater than the number of observations, then a model can perfectly predict the training data simply by memorizing the data in its entirety. Such a model, though, will typically fail severely when making predictions.</p>


<img src="/img/overfitting/overfitting.png" style="display: block; margin-left: auto; margin-right: auto;width: 300px;height: 300px;">

<p>In the above image, the green line represents an overfitted model. Indeed, even if it is the one that best follows the training data, it is too dependent on that data, thus it will probably have an high error rate on unseen samples.</p>
<p>A more detailed view of this problem is described in the post <a href="/posts/bias-variance-and-model-selection/">Bias-Variance Tradeoff</a>.</p>
<h2 id="how-can-we-measure-generalization">How can we measure generalization?<a hidden class="anchor" aria-hidden="true" href="#how-can-we-measure-generalization">#</a></h2>
<p>The training set error is not a valid measure of performance since it&rsquo;s an optimistically biased estimate of the prediction error. The classifier, indeed, has been learned exactly on that data. Therefore, we need to test on an independent new test set.</p>


<img src="/img/overfitting/partition-two-sets.svg" style="display: block; margin-left: auto; margin-right: auto;width: 800px;height: 80px;">

<p>How can we affect performance on the test set when we get to observe only the training set? If the training and the test set are collected arbitrarily, there is indeed little we can do. If we are allowed to make some assumptions about how the training and test set are collected, then we can make some progress. These assumptions are collectively known as the <strong>i.i.d. assumptions</strong>, and they imply that the examples in each dataset are independent from each other, and that the train set and the test set are identically distributed, i.e. drawn from the same probability distribution. This probabilistic framework and the i.i.d. assumptions allow us to mathematically study the relationship between training error and test error. <a href="http://www.deeplearningbook.org/">[Deep Learning - pag. 111]</a></p>
<p>Note however that when we have to train a machine learning algorithm, the latter has many settings called <strong>hyperparameters</strong> (e.g. $\lambda$ in weight decay). In order to select the best value for each hyperparameter, we need a set of samples on which tune our model. That&rsquo;s why, for the same reason that took us to split the dataset in training set and test set, it is good practice to split the dataset into one more set, called <strong>validation set</strong>.</p>


<img src="/img/overfitting/partition-three-sets.svg" style="display: block; margin-left: auto; margin-right: auto;width: 800px;height: 80px;">

<p>Finally all the preparation is done. Summarizing:</p>
<ul>
<li>We train the model on the training set</li>
<li>We evaluate the model on the validation set</li>
<li>We tweak the model according to the results on validation set</li>
<li>We select the model that performs best on validation set</li>
<li>We test the model on the test set</li>
</ul>
<p><strong>Important: never train on test data!</strong></p>
<p><em>Test sets and validation sets &ldquo;wear out&rdquo; with repeated use. That is, the more you use the same data to make decisions about hyperparameter settings or other model improvements, the less confidence you&rsquo;ll have that these results actually generalize to new, unseen data.</em> <a href="https://developers.google.com/machine-learning/crash-course/validation/another-partition">[Google ML crash course]</a></p>
<h2 id="cross-validation">Cross-validation<a hidden class="anchor" aria-hidden="true" href="#cross-validation">#</a></h2>
<p>When you have enough data, the method with the validation set described before is a good idea. However, when the dataset is too small you would like to not &ldquo;waste&rdquo; so many data that instead could be used for training. Cross-validation techniques solve exactly this problem:</p>
<h4 id="leave-out-out-loo-cross-validation">Leave-Out-Out (LOO) cross-validation<a hidden class="anchor" aria-hidden="true" href="#leave-out-out-loo-cross-validation">#</a></h4>
<p>A set of $n$ data points is repeatedly split into a training set containing all but one observation, and a validation set that contains only that observation. The test error is then estimated by averaging the $n$ resulting MSE&rsquo;s.</p>
<p>$$
L_{LOO} = \frac{1}{N} \sum_{n=1}^{N} (t_n - y_{D \setminus {n}}(x_n))^2
$$</p>
<p>LOOCV generally gives the best result, but the price to pay is an high computational cost. If the dataset is small, it is the best approach (unless you are Google and you can use it even with a big dataset since the computational power is not a problem).</p>
<h4 id="k-fold-cross-validation">K-fold cross-validation<a hidden class="anchor" aria-hidden="true" href="#k-fold-cross-validation">#</a></h4>
<p>A set of $n$ observations is randomly split into $k$ non-overlapping groups. Each of these groups is used as a validation set, and the remainder as a training set. The test error is estimated by averaging the $k$ resulting MSE&rsquo;s.</p>
<p>$$
L_{D_i} = \frac{k}{N} \sum_{(x_n,t_n) \in D} (t_n - y_{D \setminus {D_i}}(x_n))^2
$$</p>
<p>$$
L_{kfold} = \frac{1}{k} \sum_{i=1}^{k} L_{D_i}
$$</p>
<p>K-fold cross-validation is much faster than LOO, but it is more (pessimistically) biased.</p>
<h2 id="early-stopping-limiting-overfitting-by-cross-validation">Early Stopping: Limiting Overfitting by Cross-validation<a hidden class="anchor" aria-hidden="true" href="#early-stopping-limiting-overfitting-by-cross-validation">#</a></h2>
<p>How can we know that our network is overfitting? Overfitting networks show a monotone training error trend (on average with SGD) as the number of gradient descent iterations $k$, but they lose generalization at some point&hellip;</p>


<img src="/img/overfitting/overfitting-underfitting.png" style="display: block; margin-left: auto; margin-right: auto;width: 450px;height: 300px;">

<p>Image taken from <em><a href="https://towardsdatascience.com/cross-validation-70289113a072">https://towardsdatascience.com/cross-validation-70289113a072</a></em></p>
<p>Every time the error on the validation set improves, we store a copy of the model parameters. When the training algorithm terminates, we return these parameters, rather than the latest parameters. The algorithm terminates when no parameters have improved over the best recorded validation error for some pre-specified number of iterations. It is probably the most commonly used form of regularization in deep learning. Its popularity is due both to its effectiveness and its simplicity.</p>
<p>The only significant cost to choosing this hyperparameter automatically via early stopping is running the validation set evaluation periodically during training. Ideally, this is done in parallel to the training process on a separate machine, separate CPU, or separate GPU from the main training process.</p>
<p>Moreover, since early stopping requires a validation set, some training data are not fed to the model. To overcome this problem, we can perform an extra training procedure with all the data after the one with early stopping has finished. This extra training procedure can be done in two different ways:</p>
<ul>
<li>Initialize the model again and retrain with all the data for a number of steps equal to the one determined by the early stopping algorithm.</li>
<li>Keep the parameters obtained from the early stopping algorithm and continue training with all the data. Note that this strategy has the advantage of not needing to retrain the model from scratch, but it is not guaranteed to terminate.</li>
</ul>
<p>If you want to better understand <strong>How early stopping acts as a regularizer</strong> see the <a href="http://www.deeplearningbook.org/">Deep Learning</a> book at page 249. In few words, the idea is that by limiting the number of steps performed by the gradient descent in the loss function that we want to minimize, we are limiting the volume of parameter space reachable from an initial parameter. So we can say that somehow early stopping is similar to weight decay, but with the advantage that it can figure out for itself what is the right amount of regularization to apply, while weight decay needs to tune its $\lambda$ parameter (e.g. by cross-validation).</p>
<h2 id="weight-decay">Weight Decay<a hidden class="anchor" aria-hidden="true" href="#weight-decay">#</a></h2>
<p>I&rsquo;ve already discussed this technique in another post &ndash;&gt; <a href="/posts/linear-regression/">Linear Regression</a></p>
<p>However, I will do it again here, adding some details.</p>
<p>Regularization is any modification we make to a learning algorithm that is intended to reduce its generalization error but not its training error. In case of weight decay, regularization consists of adding a penalty term to the loss function to discourage the coefficients from reaching large values.</p>
<p>So far we have maximized the data likelihood $w_{MLE} = argmax_w P(D|w)$. We can reduce the model &ldquo;freedom&rdquo; by introducing a prior distribution which influences the choice of the point estimate. This approach is called **Maximum A Posteriori (MAP)**:</p>
<p>$$
\theta_{MAP} = argmax_{\theta}\; p(\theta|x) = argmax_{\theta}\; log\; p(x|\theta) + log\; p(\theta)
$$</p>
<p>where on the right hand side the first term is the <em>likelihood</em> and the second one the <em>prior distribution</em>.</p>
<p>Consider now a linear regression model with a Gaussian prior on the weights $P(w) \sim N(0,\sigma_w^2)$.</p>
<p>$$
\displaylines{\hat{w} = argmax_w P(w|D) = argmax_w P(D|w) P(w) \\ = argmax_w \prod_{n=1}^{N} \frac{1}{\sqrt{2\pi}\sigma} e^{-\frac{(t_n-g(x_n|w))^2}{2\sigma^2}} \prod_{q=1}^{Q} \frac{1}{\sqrt{2\pi}\sigma_w} e^{-\frac{(w_q)^2}{2\sigma_w^2}} \\ = argmin_w \sum_{n=1}^{N} \frac{(t_n-g(x_n|w))^2}{2\sigma^2} + \sum_{q=1}^{Q} \frac{(w_q)^2}{2\sigma_w^2} \\ = argmin_w \sum_{n=1}^{N} (t_n-g(x_n|w))^2 + \gamma \sum_{q=1}^{Q} (w_q)^2}
$$</p>
<p>We thus have obtained a new loss function, where the second term represents the regularization. Minimizing this loss function results in a choice of weights that make a tradeoff between fitting the training data and being small. This gives us solutions that have a smaller slope, or put weight on fewer of the features.</p>
<h2 id="dropout">Dropout<a hidden class="anchor" aria-hidden="true" href="#dropout">#</a></h2>
<p>Dropout is one of the most simple but efficient techniques to regularize neural networks. The idea is pretty simple, but let&rsquo;s make a premise: in machine learning there is one technique called <strong>bagging</strong> in which different models are trained through the use of <em>bootstrapping</em>. The main goal of this technique is to reduce the variance of the overall model, with the advantage that the training process is relatively easy to parallelize.</p>
<p>Ok, so one could think of using this approach also in neural networks. Here is the problem: with very large neural networks this becomes easily impractical. Dropout provides an inexpensive approximation to training and evaluating a bagged ensemble of exponentially many neural networks. By turning off randomly some neurons, we force to learn an independent feature preventing hidden units to rely on other units (co-adaptation). Specifically, to train with dropout, we use a minibatch-based learning algorithm that makes small steps, such as stochastic gradient descent. Each time we load an example into a minibatch, we randomly sample a different <strong>binary mask</strong> to apply to all of the input and hidden units in the network. The mask for each unit is sampled independently from all of the others. The probability of sampling a mask value of one (causing a unit to be included) is a hyperparameter fixed before training begins.</p>


<img src="/img/overfitting/dropout.png" style="display: block; margin-left: auto; margin-right: auto;width: 550px;height: 250px;">

<p>Image taken from <em><a href="https://arxiv.org/pdf/1809.05165.pdf">Defensive Dropout for Hardening Deep Neural Networks under Adversarial Attacks</a></em></p>
<p>Note that there are two important differences between dropout and bagging:</p>
<ul>
<li>
<p>In the case of bagging, the models are all independent. In the case of dropout the models share parameters, with each model inheriting a different subset of parameters from the parent neural network. This parameter sharing makes it possible to represent an exponential number of models with a tractable amount of memory.</p>
</li>
<li>
<p>In the case of bagging, each model is trained to convergence on its respective training set. In the case of dropout, typically most models are not explicitly trained at all—usually, the model is large enough that it would be infeasible to sample all possible subnetworks within the lifetime of the universe. Instead, a tiny fraction of the possible sub-networks are each trained for a single step, and the parameter sharing causes the remaining sub-networks to arrive at good settings of the parameters.</p>
</li>
</ul>
<p>An interesting consequence of the fact that dropout trains not just a bagged ensemble of models, but an ensemble of models that share hidden units is that each hidden unit must be able to perform well regardless of which other hidden units are in the model. Hidden units must be prepared to be swapped and interchanged between models. <em>Hinton et al. (2012c)</em> were inspired by an idea from biology: sexual reproduction, which involves swapping genes between two different organisms, creates evolutionary pressure for genes to become not just good, but to become readily swapped between different organisms. Such genes and such features are very robust to changes in their environment because they are not able to incorrectly adapt to unusual features of any one organism or model. <strong>Dropout thus regularizes each hidden unit to be not merely a good feature but a feature that is good in many contexts.</strong></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://mett29.github.io/tags/cross-validation/">cross-validation</a></li>
      <li><a href="https://mett29.github.io/tags/dropout/">dropout</a></li>
      <li><a href="https://mett29.github.io/tags/early-stopping/">early stopping</a></li>
      <li><a href="https://mett29.github.io/tags/overfitting/">overfitting</a></li>
      <li><a href="https://mett29.github.io/tags/weight-decay/">weight decay</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://mett29.github.io/">Matt Log</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
